<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NewbiePy</title>
    <link rel="stylesheet" href="style.css">
	<link rel="icon" href="favicon.png" type="image/png">
</head>
<body>
    <header class="header">
    <div class="logo"><span class="name">&lt;</span> <span class="name">.</span> NewbiePy <span class="name">&gt;</span></div>
    <nav class="tabs">
      <a href="index.html" class="tab-btn" >Главная</a>
      <a href="python.html" class="tab-btn" >Python</a>
      <a href="html5.html" class="tab-btn" >HTML5</a>
      <a href="css3.html" class="tab-btn" >CSS3</a>
    </nav>
  </header>

<div class="container">
    <!-- Вкладка: Python -->
    <div id="python" class="tab-content">
      <h2>Python</h2>
      <nav class="toc">
        <a href="#python-basics" class="toc-link">1. Знакомство с Python</a>
        <a href="#python-types" class="toc-link">2. Типы данных</a>
        <a href="#python-conditions" class="toc-link">3. Операторы ветвлений, Циклы, Исключения</a>
        <a href="#python-str-list" class="toc-link">4. Строки, Списки</a>
        <a href="#python-collections" class="toc-link">5. Кортежи, Множества, Словари</a>
        <a href="#python-function" class="toc-link">6. Функции</a>
        <a href="#python-sort" class="toc-link">7. Сортировка, Поиск</a>
        
      </nav>
      <article>

        <section id="python-basics">
          <h2>1. Знакомство с Python</h2>
          <h3>Что такое Python? Разбор терминов</h3>
            <p><b>1. PYTHON :</b> <br>
1.1. <b><i>Объектно-ориентированный</i></b> -> Всё в Python — объекты: числа, строки, функции, классы и даже модули; <br>
1.2. <b><i>Интерпретируемый</i></b> -> Код выполняется построчно интерпретатором.  <br>
Интерпретатор переводит код в байт‑код, который затем выполняется виртуальной машиной Python (PVM). <br>
   + Плюсы: <br>
++ быстрая разработка и отладка (не нужно компилировать); <br>
++ переносимость (один и тот же код работает на разных системах). <br>
   - Минусы: <br>
-- обычно медленнее компилируемых языков (C, Go); <br>
-- требуется среда разработки (интерпретатор Python). <br>

1.3. <b><i>Высокоуровневый</i></b> -> <br>
-- Программист думает о логике задачи, а не о том, как именно процессор выполнит инструкцию. <br>
-- Автоматическое управление ресурсами: <br>
--- Сборщик мусора освобождает память от неиспользуемых объектов; <br>
--- Нет необходимости вручную выделять/освобождать память. <br>

1.4. <b><i>Кроссплатформенный</i></b> -> Код работает на разных операционных системах; <br>

1.5. <b><i>Динамический</i></b> -> Динамическая типизация: типы переменных определяются во время выполнения; <br>

1.6. <b><i>Простой</i></b>  язык программирования -> <br>
-- Читаемый синтаксис; <br>
-- Низкий порог входа: можно написать работающий код за несколько строк. <br>
            </p>

          <h3>Сфера применения. Приложения. Аналоги языка</h3>
<p>
<b>Примеры: </b><br>
1. Netflix <br>
Python применяется в Netflix для анализа данных, построения рекомендаций и автоматизации процессов. <br>
2. Spotify <br>
Музыкальный стриминговый сервис использует Python для бэкенд-систем, включая алгоритмы рекомендаций, а также в определённых компонентах мобильного приложения. <br>
3. Dropbox <br>
Облачное хранилище файлов, позволяющее синхронизировать данные между устройствами. <br>
4. Pinterest <br>
Социальная сеть для сохранения и обмена визуальным контентом (изображениями, идеями, рецептами и т. п.) с тематическими доскам и рекомендациями. <br>
 <br>

<b>Аналоги и Конкуренты</b>:<br>
<b><i>* Python </i></b><br>
&emsp;<b><i> Сильные стороны:</i></b> Простота, экосистема, Data Science; <br>
&emsp;<b><i> Слабые стороны:</i></b> Производительность, GIL; <br>
&emsp;<b><i> Лучший сценарий:</i></b> Веб, ML, автоматизация. <br>

<b><i>Go </i></b><br>
&emsp;<b><i> Сильные стороны:</i></b> Производительность, конкурентность; <br>
&emsp;<b><i> Слабые стороны:</i></b> ПМеньше библиотек, строгая типизация; <br>
&emsp;<b><i> Лучший сценарий:</i></b> Микросервисы, облачные сервисы. <br>

<b><i>Java </i></b><br>
&emsp;<b><i> Сильные стороны:</i></b> Масштабируемость, экосистема; <br>
&emsp;<b><i> Слабые стороны:</i></b> Громоздкость, медленная разработка; <br>
&emsp;<b><i> Лучший сценарий:</i></b> Enterprise, Android. <br>

<b><i>Rust </i></b><br>
&emsp;<b><i> Сильные стороны:</i></b> Безопасность памяти, скорость <br>
&emsp;<b><i> Слабые стороны:</i></b> Сложность, долгий компилятор <br>
&emsp;<b><i> Лучший сценарий:</i></b> Системное ПО, криптография <br>
<br>
 <i>Выбор зависит от задачи, команды и инфраструктуры.</i> <br>
Python остаётся лидером в ML и автоматизации, но в других областях его могут превосходить специализированные языки: <br>
-- Для быстрого старта и универсальности → Python, JavaScript. <br>
-- Для высокой нагрузки и микросервисов → Go, Rust. <br>
-- Для Data Science → Python, R, Julia. <br>
-- Для enterprise и Android → Java, Kotlin. <br>
-- Для веба с полным стеком → JavaScript/TypeScript + Node.js. <br>
</p>

          <h3>Алгоритм</h3>
<p><b><i>БЛОК-СХЕМА -</i></b> граф.способ описания алгоритмов <br>
<b><i>Свойства алгоритма:</i></b> <br>
    &emsp;- результативность; <br>
    &emsp;- корректность; <br>
    &emsp;- точность; <br>
    &emsp;- понятность; <br>
    &emsp;- дискретность(последовательность действий друг за другом); <br>
    &emsp;- массовость. <br>

<b><i>Типы алгоритмов:</i></b> <br>
    &emsp;- линейный (друг за другом); <br>
    &emsp;- циклический (повтор одних и тех же действий); <br>
    &emsp;- разветвленный (есть варианты). <br>


</p>


          <h3>Разница между Интерпретацией и Компиляцией</h3>
<p>
	<b>КОМПИЛЯЦИЯ:</b> <br>
  &emsp;перевод всего текста сразу → <br>
     &emsp; &emsp;готовый файл → <br>
         &emsp; &emsp; &emsp;быстрое исполнение. <br>
        * <i>Компиляция</i> - файл exe, закрытый код, который сложно взламывать. * <br>

 <b>ИНТЕРПРЕТАЦИЯ: </b><br>
 &emsp;перевод по строкам во время работы → <br>
    &emsp;&emsp;нет готового файла → <br>
        &emsp;&emsp;&emsp;медленнее, но удобнее для разработки. <br>
    * <i>Интерпретация</i> - редактируемый открытый программный код, который можно запускать произвольное количество раз.
    Требуется программа интерпретатор. * <br></p>



          <h3>Среда разработки</h3>
<p><b>&emsp;Среда разработки (IDE, Integrated Development Environment)</b>
     — это программное обеспечение, 
     объединяющее инструменты для полноценной работы 
     над программным продуктом в едином интерфейсе. <br>
    &emsp;Это «рабочее место программиста» — единая среда, 
     где можно писать, проверять, запускать и выпускать код, 
     не выходя за пределы одного приложения. <br>
<b>&emsp;<i>IDE позволяет: </i></b><br>
  - <i>писать код</i> — встроенным текстовым редактором с подсветкой синтаксиса, автодополнением и форматированием; <br>
  - <i>компилировать</i> — автоматически преобразовывать код в исполняемый формат; <br>
  - <i>запускать и отлаживать</i> — выполнять программу пошагово, ставить точки останова, анализировать переменные; <br>
  - <i>тестировать</i> — интегрировать юнит‑тесты и проверять работоспособность; <br>
  - <i>управлять версиями</i> — работать с Git и другими системами контроля версий; <br>
  - <i>настраивать сборки</i> — собирать проект по шаблонам (Makefile, Maven, Gradle и т. п.); <br>
  - <i>устанавливать плагины</i> — расширять функционал под конкретные языки и задачи. <br>
<b>&emsp;<i>Примеры</i></b> популярных IDE: <br>
 - Visual Studio (C#, C++, F#); <br>
 - PyCharm (Python); <br>
 - Eclipse (Java и др.); <br>
 - IntelliJ IDEA (Java, Kotlin, Groovy); <br>
 - VS Code (многоязыковая, лёгкая, с большим набором плагинов). <br>
</p>

          <h3>Escape-Последовательности. Экранирование</h3>
<p>&emsp;<i>Вывод СПЕЦСИМВОЛОВ и работа с escape-последовательностями: </i><br>
    - \n - переход на новую строку (new line) <br>
    - \t - 4 пробела <br>
&emsp;<b><i>ЭКРАНИРОВАНИЕ</i></b> - вывод спец символов, 
которые распознаются как команда,
чтобы они выводились как символы - ставим один \ перед ними. <br>
Пример спец символов: &emsp; '&emsp; "&emsp; \ <br>
    - \\ - вывод \ одного слэша ;<br>
    - \" или \'  .<br></p> 

        </section>

        <section id="python-types">
          <h2>2. Типы данных</h2>
          <h3>Переменные. Виды(локальные, глобальные). Правила записи</h3>
<p> <b><i>ПЕРЕМЕННАЯ</i></b> - ячейка памяти, которая хранит в себе данные,
может хранить в себе любые символы; <br>
<b><i>&emsp;Виды переменных:</i></b> <br>
- Глобальные — видны везде, живут всё время работы программы.   <br>
- Локальные — видны только внутри функции, исчезают после её завершения. <br>
<b><i>&emsp;Глобальные:</i></b> <br>
- Определяются вне функций (обычно в начале файла).   <br>
- Доступны в любом месте программы, включая функции.   <br>
- Сохраняют значение между вызовами функций.   <br>
<b><i>&emsp;Локальные:</i></b><br>
- Создаются внутри функции при её вызове.   <br>
- Доступны только внутри этой функции.   <br>
- Уничтожаются после завершения работы функции.   <br>
<b><i>&emsp;Важные нюансы :</i></b> <br>
1. Если внутри функции присвоить значение переменной (например, x = 20),  <br>
Python создаст локальную переменную, даже если глобальная с таким именем уже есть.   <br>
2. Чтобы изменить глобальную переменную внутри функции, нужно явно указать global: 
<pre> x = 10
def func():
    global x
    x = 20  # меняем глобальную x
func()
print(x)  # 20</pre>
3. Если просто читать глобальную переменную внутри функции — global не требуется.<br>
<br>

<b>Правила именования переменных </b><br>
<b><i>&emsp;Можно:</i></b> <br>
 - буквы (a-z, A-Z); <br>
 - цифры (0-9), но не в начале; <br>
 - символ подчёркивания _. <br>
<b><i>&emsp;Нельзя: </i></b><br>
 - начинать с цифры (1var — ошибка); <br>
 - использовать дефисы (-), пробелы, спецсимволы (@, # и т. п.); <br>
 - называть переменную как ключевое слово Python (if, else, for, class и др.). <br>
<b><i>&emsp;Регистр важен:</i></b> name, Name, NAME — три разные переменные. <br>
<b><i>&emsp;Рекомендации</i></b> по стилю (PEP 8): <br>
 - snake_case для переменных и функций: user_name, max_count; <br>
 - UPPER_CASE для констант: MAX_SIZE, API_KEY; <br>
 - имена должны быть осмысленными (не x, а, например, user_age). <br>

</p>

          <h3>Тип данных. Преобразование типов данных</h3>
<p><b><i>&emsp;ТИП ДАННЫХ</i></b> - что именно хранит в себе переменная. <br>
<b><i>&emsp;ПРЕОБРАЗОВАНИЕ ТИПА ДАННЫХ</i></b> - это изменение типа переменной или значения (например, строки в число, числа в строку и т. п.). <br>
Существуют <b>ИЗМЕНЯЕМЫЕ и НЕИЗМЕНЯЕМЫЕ</b> типы данных:  <br>
&emsp;1. <b>НЕИЗМЕНЯЕМЫЕ (immutable)</b> - Объекты нельзя модифицировать после создания
— любые попытки «изменения» приводят к созданию нового объекта. <br>
<b><i>(*Числовой тип, Строковый, Логический + Кортеж*)</i></b> <br>
 - <b><i>int </i></b>— целые числа (42, -7); <br>
 - <b><i>float </i></b> — числа с плавающей точкой (3.14, -0.5); <br>
 - <b><i>bool </i></b> — логические значения (True, False); <br>
 - <b><i>str </i></b> — строки ("привет", 'Python'); <br>
 &emsp;<b><i>-> СТРОКИ  </i></b> - упорядоченная НЕИЗМЕНЯЕМая последовательность символов. <br>
 - <b><i>tuple</i></b>  — кортежи ((1, 2, 3), ("a", "b")); <br>
&emsp;<b><i>->  КОРТЕЖ ()</i></b> - tuple() — это упорядоченная и НЕИЗМЕНЯЕМАЯ коллекция элементов,
 которые могут быть разных типов. <br>
 - Если внутри кортежа есть изменяемый объект (например, список),
    его содержимое можно изменить; <br>
 - <b><i>frozenset</i></b>  — неизменяемое множество (создаётся через frozenset([1, 2, 3])); <br>
 - <b><i>bytes </i></b> — последовательность байтов (b'hello'); <br> 
 - <b><i>complex </i></b>  — комплексные числа (3+4j).<br>
 <br>
&emsp;2. <b>ИЗМЕНЯЕМЫЕ типы (mutable)</b> - Объекты можно модифицировать после создания
— менять содержимое без создания нового объекта. <br>
<b><i>(*Список, Словарь, Множество*)</i></b> <br>
 - <b><i>list</i></b> — списки ([1, 2, 3], ["a", "b"]); <br>
 &emsp;<b><i>-> СПИСОК []</i></b> - list() - упорядоченная ИЗМЕНЯЕМАЯ коллекция данных. <br>
 - <b><i>dict</i></b> — словари ({"name": "Alice", "age": 30}); <br>
 &emsp;<b><i>-> СЛОВАРИ {}</i></b> - dict() - это ИЗМЕНЯЕМАЯ коллекция пар «ключ‑значение». <br>
SYNTAX: d = {key1 : value1, key2 : value2,...} <br>
	- <b><i>Ключ </i></b>- ТОЛЬКО НЕИЗМЕНЯЕМЫЙ тип данных; <br>
    - <b><i>Значение</i></b> - ЛЮБОЙ тип данных. <br>
 - <b><i>set</i></b> — множества ({1, 2, 3}); <br>
 &emsp;<b><i>-> МНОЖЕСТВО {}</i></b> - set() — это ИЗМЕНЯЕМАЯ неупорядоченная коллекция 
 уникальных элементов, где каждый элемент встречается только один раз
 и должен быть НЕИЗМЕНЯЕМЫМ объектом (число, строка, кортеж и т. п.). <br>
 - <b><i>bytearray</i></b> — изменяемая последовательность байтов (bytearray(b'hello')); <br>
 - Экземпляры пользовательских классов (по умолчанию). <br>
 ********** <br>
 КРАТКО: <br>
 Строки -- "НЕИЗ" <br>
 Список -- ИЗ[] <br>
 Словарь -- ИЗ{ НЕИЗ : Л } <br>
 Кортеж -- НЕИЗ( Л ) <br>
 Множество -- ИЗ{ НЕИЗ } <br>
  ********** <br>
</p>

          <h3>Операторы и Операнды</h3>
<p>
     &emsp;<b><i>ЛОГИЧЕСКИЕ ОПЕРАТОРЫ</i></b> &lt; &gt; == ! = <br>
    &&  - логическое И and <br>
    || - логическое ИЛИ or <br>
     &emsp;<b><i>АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ</i></b> <br>
    + сложение <br>
    - вычитание <br>
    * умножение <br>
    / деление <br>
    % деление с остатком <br>
    <b><i>Пример:</i></b><br>
    "3 - 2": <br>
    - Оператор - "-" <br>
    - Операнд - 3, 2 <br>
 <br>
<b><i>Арифметические операции ДЕЛЕНИЯ: </i></b><br>
    1 - деление целочисленное 5//2= 2 <br>
    2 - деление с остатком 5%2=1 <br>
    3 - деление обычное 5/2=2,5 <br>
 
 ************<br>
+Получаем последнюю цифру числа %10 {455%10} <br>
+Получаем две последние цифры числа %100 {455%100} <br>
+Получаем полное трехзначное число %1000 {455%1000} <br>
+Получаем все цифры, кроме последней //10 = {455//10} <br>
+Получаем все цифры, кроме двух последних //100 = {455//100} <br>
+Получаем все цифры, кроме последних трех //1000 = {455//1000} <br>
 ************<br></p>

          <h3>Приоритеты операторов</h3>
<p><b><i>&emsp;Примеры:</i></b> <br>
5 + 2 * 3 → сначала умножение (2*3=6), потом сложение (5+6=11). <br>
2 ** 3 ** 2 → справа налево: 3**2=9, затем 2**9=512. <br>
(5 + 2) * 3 → сначала скобки (5+2=7), потом умножение (7*3=21). <br>
<b><i>&emsp;Упрощённая иерархия приоритетов (от высшего к низшему)</i></b> <br>
1. () — скобки (высший приоритет). <br>
2. ** — возведение в степень. <br>
3. *, /, //, % — умножение, деление, целочисленное деление, остаток. <br>
4. +, - — сложение и вычитание. <br>
5.Операторы сравнения (==, !=, &lt;, &gt;, &lt;=, &gt;=, in, not in, is, is not). <br>
6. not — логическое «НЕ». <br>
7. and — логическое «И». <br>
8. or — логическое «ИЛИ». <br>
9.Операторы присваивания (=, +=, -= и др.). <br></p>

          <h3>Ввод/вывод</h3>
          <p><b>ВВОД значения переменной - input()</b>  <br>
    - int(input()) - ввод целого числа <br>
    - float(input()) - ввод дробного числа <br>
    - str(input()) - ввод строки <br>
    - bool(input()) - ввод логического значения <br>
<b>ВЫВОД  - print()  </b><br>
- input с аргументом - внутри есть число /строка <br></p>

          <h3>Ошибки синтаксические и логические</h3>
          <p>&emsp;<b><i>Синтаксические: </i></b>   <br>
1. Непарные скобки/кавычки    <br>
2. Отсутствие двоеточий после условных конструкций      <br>
3. Неправильные отступы (табуляция vs пробелы)      <br>
4. Опечатки в ключевых словах    <br>
5. Забытые запятые в списках/словарях    <br>
6. Некорректные имена переменных    <br>
&emsp;<b><i>Логические: </i></b>   <br>
1. Условия всегда истинны/ложны    <br>
2. Путаница and / or      <br>
3. Ошибка «на единицу» в циклах      <br>
4. Изменение списка во время итерации     <br> 
5. Неверное сравнение типов    <br>
6. Забытое обновление переменной      <br>
7. Бесконечный цикл      <br>
8. Неправильное использование is vs ==     <br> 
9. Ошибка области видимости (scope)     <br>
10. Неучёт None или пустых значений      <br>

          </p>
        </section>

        <section id="python-conditions">
          <h2>3. Операторы ветвлений, Циклы, Исключения</h2>
          <h3>Логические выражения и операторы</h3>
          <p>
&emsp;<b><i>УНАРНЫЕ операторы</i></b> - print(-3), -3 унарный оператор, делает число отрицательным;  <br>
&emsp;<b><i>БИНАРНЫЕ операторы</i></b> - 3-2, 3+2, 3*2, 3/2 - если по обе стороны стоит операнд - то оператор Бинарный  <br>
 =, ==, &lt;, &gt;, &lt;=, &gt;=  <br>
 &emsp;<b><i>ТЕРНАРНЫЙ оператор </i></b>- замена команды if else:  <b>&lt;значение1&gt; if &lt;условие&gt; else &lt;значение2&gt;  </b><br>
</p>
          <h3>Операторы ветвления if-else</h3>
        <p>
<b><i>УСЛОВИЕ </i></b>- когда в программе есть выбор, то используем конструкции:  <br>
<pre>
<hr>1   if условие:  
        действие1  
<hr>2   if условие:  
        действие1  
    else:  
        действие2  
<hr>3   if условие_1:  
        действие1  
    elif условие_2:  
        действие2  
<hr>4/1   if условие_1:  
        действие1  
    elif условие_2:  
        действие2  
    else:  
        действие3  
<hr>4/2   if условие_1:  
        действие1  
        else:  
            if условие_2:  
                действие2  
            else:  
                действие3  
<hr></pre>
  <br>
&emsp;<b><i>Разбор и применение  </i></b> <br>
    <b><i>if </i></b>- действие внутри выполнится, если условие True;  <br>
    <b><i>if else</i></b> - действие обязательно выполнится или в if, или в else:  <br>
        - если условие True, то выполняем в if;  <br>
        - если условие False, то выполняем в else.  <br>
    <b><i>if elif</i></b> - действие внутри выполнится, если одно из условий True:  <br>
        - Содержит 2 условия;  <br>
        - Если 1е условие выполняется, то не попадаем в else if;  <br>
        - Если 1е условие не выполняется, то попадаем в else и идем на проверку 2го условия.  <br>
    <b><i>if elif else</i></b> - действие обязательно выполнится:  <br>
        - Расшифровывается if else if else;  <br>
        - Это вложенная конструкция.  <br>
</p>
         
          
        <h3>Определение Исключений. Типы. Перехват. Конструкция try-except</h3>
<p>
 &emsp;<b><i>ИСКЛЮЧЕНИЯ</i></b> - это событие, возникающее при выполнении программы
 и нарушающее её нормальный поток,
 а также объект, который обозначает различные типы состояний отказа программы
 и содержит информацию об ошибке
 (тип ошибки, состояние программы на момент возникновения ошибки, описание ошибки). <br>
&emsp;<b><i>try... except </i></b> - Конструкция убирает критическую ошибку. <br>
try … except ValueError: <br>
#except  ZeroDivisionError: #отлавливает Определенное исключение <br>
#except: #отлавливает Все исключения <br></p>

          <h3>Определение Цикла и Итерации</h3>
<p>
&emsp;<b><i>ЦИКЛЫ </i></b>- набор повторяющихся действий; <br>
&emsp;<b><i>ИТЕРАЦИИ</i></b> — это многократное выполнение одного и того же блока кода (тела цикла)
 для обработки элементов коллекции или пока выполняется заданное условие; <br>
&emsp;<b><i>ИТЕРИРУЕМЫЕ ОБЪЕКТЫ</i></b> - перебирают ЛЮБОЙ тип данных в коллекции. </p>
          <h4>Виды циклов. Бесконечные циклы</h4>
<p>
    ВСЕ циклы можно сделать бесконечными - условие всегда должно быть истинным.  <br>
+ Виды: while and for  <br>
<hr>
<pre>- while условие:
    действие1
<hr>- Бесконечный цикл 
    while True:
    	действие1
<hr>- for x in range (0,10,1):
    action1
<hr></pre>
<br>
&emsp;<b><i>WHILE</i></b>  - цикл со счетчиком.   <br>
while - выполняется до тех пор, пока выражение не станет False; <br>
Переменная number1 показывает сколько раз выполнится цикл.  <br>
<hr>
<pre>
number1 = 1
while number1 &lt;= 5:
    print(f"{number1}")
    number1 = number1 + 1
<hr>
&emsp;<b><i>FOR</i></b> 
for x in range(1, 6, 1):
    print(f"x= {x}")
#1 - start
#6 - end - not included
#1 - step
<hr>
</pre>&emsp;<b><i>ВЛОЖЕННЫЕ ЦИКЛЫ</i></b>  <br>
 - Синтаксис:  <pre>
 while condition1:
    while condition2:
        print(action1)
 for i in range(start, end, step):
    for j in range(start, end, step):
        print(action1)
<hr>
</pre>
<b>WHILE ELSE  </b><br>
 &emsp;Конструкция while else — это конструкция цикла,
 которая выполняет блок кода ELSE,
 когда условие в WHILE становится ложным и цикл завершается естественным образом,
 а не прерывается оператором BREAK.  <br>
 &emsp;Блок ELSE выполняется только в том случае,
 если цикл не был прерван с помощью BREAK.  <br></p>

          <h3>Операторы break, continue, else</h3>
         <p>
    - <b><i>break </i></b>- (остановка) прерывание цикла (ПОМЕСТИТЬ МОЖНО ТОЛЬКО В ЦИКЛ) 
    - выход за его пределы - выкидывет из цикла;<br>
    - <b><i>continue </i></b> - оператор прерывания цикла/ проверяет условие еще раз, 
    и если оно не выполнилось, то выбрасывает за пределы цикла; <br>
</p>
        </section>





        <section id="python-str-list">
          <h2>4. Строки, Списки</h2>
          <h2>1. Строки</h2>
          <h3>Определение Строк. Создание</h3>
<p> &emsp;<b><i>СТРОКА </i></b> - упорядоченный НЕИЗМЕНЯЕМЫЙ набор символов. <br>
    <i>Создание <b>строки: </b></i> <br>
		&emsp;- переменная = ""  <br>
		&emsp;- переменная = ''  <br>
	<i>Создание <b>многострочного значения:</b></i> <br>
		&emsp;- переменная = """ ......"""  <br>
		&emsp;- переменная = ''' ......''' <br></p>
<h3>Операции над строками</h3>
<p> + - Конкатенация - склеивание строк между собой -- Работает ТОЛЬКО с типом str ;  <br>
	* - Дублирование - размножение строкового фрагмента -- "ха " * 3 = ха ха ха . <br>
	<b><i>Функции: </i></b> <br>
		&emsp;- len() - вычисление длины строки - принимает строку или строковую переменнную;  <br>
		&emsp;- str() - для преобразования аргумента в строковое представление;  <br>
		&emsp;- ord() - определение кода символа.  <br>
	<b><i>Оператор in </i></b>- проверяет вхождение подстроки в строку -- 'ab' in 'abracadabra' ;<br>
	<b><i>Сравнение строк: </i></b> <br>
		&emsp;- (==) - ищет только ИДЕНТИЧНЫЕ символы - "привет" != " привет" или "Привет" ; <br>	
		<b><i>ASCII - кодовая таблица </i></b>  <br>
		&emsp;- 'кот' > 'кит' = True, так как буква "и"(и - легче) в алфавите идет первее "о"(о - тяжелее), соответственно у букв разный вес и код; <br>
		&emsp;- 'кот' > 'Кот' = True, так как заглавные буквы расположены впереди строчных, поэтому заг.буквы легче и имеют другой код.  <br>
</p>
<h3>Способы моификации строк</h3>
<p>
<h4>Методы Строк. Срезы</h4>
	<p>&emsp;- в переменную вкладывается строковый объект ; <br>
<b>Объект.Метод(Аргументы): </b> <br>
		<b><i>- .upper()</i></b> - все в верхний регистр  <br>
		<b><i>- .lower()</i></b> - все в нижний регистр  <br>
		<b><i>- .count(sub[, start[, end]])</i></b> - метод возвращает число повторений подстроки в строке: <br>
		&emsp;*в квадратных скобках обозначаются необязательные параметры*   <br>
		&emsp;	- start - индекс начала поиска;  <br>
		&emsp;	- end - индекс конца поиска.  <br>
		&emsp;&emsp;	** str.count('ra', 4, 11) ** <br>
		<b><i>- .find(sub[, start[, end]])</i></b> - СЛЕВА НАПРАВО возвращает ИНДЕКС первого найденного вхождения подстроки в строке:  <br>
		&emsp;&emsp;	**str.find('br') -- 1 -- номер индекса, с которого начинается искомая подстрока**  <br>
		&emsp;&emsp;	**str.find('br', 2) -- 8 -- номер индекса второго совпадения подстроки в строке**  <br>
		&emsp;&emsp;	- если подстрока не найдена, то метод возвращает -1 . <br>
		<b><i>- .rfind(sub[, start[, end]]) </i></b>- СПРАВА НАЛЕВО возвращает ИНДЕКС первого найденного вхождения подстроки в строке: <br>
		&emsp;&emsp;	*возвращает индекс первого найденного вхождения при поиске СПРАВА*  <br>
		<b><i>- .index(sub[, start[, end]])</i></b> - работает также как .find, но если совпадений не находит, то выводится ошибка.  <br>
		<b><i>- .replace(old, new, count = -1)</i></b> - выполняет замену подстрок: <br>
		&emsp;&emsp;	*count - максимальное количество замен (-1 - без ограничений)*	  <br>
		<b><i>- .isalpha()</i></b> - возвращает True если строка ЦЕЛИКОМ состоит из букв:  <br>
		&emsp;&emsp;	*если в строке есть пробелы, то возвращает False*  <br>
		<b><i>- .isdigit()</i></b> -	возвращает True если строка ЦЕЛИКОМ состоит из цифр:  <br>
		&emsp;&emsp;	*если есть точка(или любые другие символы), то возвращает False*  <br>
		<b><i>- .rjust(width[, fillchar = ''])</i></b> - возвращает возвращает строку с заданным числом символов width, 
		при необходимости Слева добавляет символы-заполнители fillchar (ТОЛЬКО 1 символ):  <br>
			&emsp;&emsp;*расширяет строку, добавляя символы Слева*  <br>
			&emsp;&emsp;** d.rjust(5) -- '  abc' -- всего в строке стало 5 символов и текст выравнивается справа ** <br>
			&emsp;&emsp;** d.rjust(4, '0') -- '0012' -- '0' это символ-заполнитель  **<br>
		<b><i>- .ljust(width[, fillchar = '']) </i></b>- возвращает возвращает строку с заданным числом символов width, 
		при необходимости Справа добавляет символы-заполнители fillchar (ТОЛЬКО 1 символ):  <br>
			&emsp;&emsp;*расширяет строку, добавляя символы Справа * <br>
			&emsp;&emsp;** d.ljust(5, '*') -- '12***' -- '0' это символ-заполнитель ** <br>
		<b><i>- .split(sep=None, maxsplit = -1)</i></b> - возвращает КОЛЛЕКЦИЮ СТРОК, на которое разбивается исходная строка: <br>
			&emsp;&emsp;* sep - фрагмент разбиения строки - разбивка по УКАЗАННОМУ сепаратору*  <br>
			&emsp;&emsp;** "Иванов Иван Иванович".split(" ") -- ['Иванов', 'Иван', 'Иванович'] ** <br>
		<b><i>- .join(список)</i></b> - из списка строк собирает единую строку:  <br>
			&emsp;&emsp;* указываем символ который будет стоять между элементами списка*  <br>
			<hr>
<pre>
d = ['1', '2', '3', '4']  
   ", ".join(d) -- '1, 2, 3, 4' 
<hr>fio = Ианов Иван Иванович 
   ", ".join(fio.split()) -- 'Иванов, Иван, Иванович'  </pre>
<hr><br>
		<b><i>- .strip()</i></b> - удаляет все символы пробелов и переносов строк в начале и конце строки (ПО БОКАМ);	  <br>
		<b><i>- .rstrip()</i></b> - удаляет все символы пробелов и переносов строк в конце строки (СПРАВА);	  <br>
		<b><i>- .lstrip()</i></b> - удаляет все символы пробелов и переносов строк в начале строки (СЛЕВА);  <br>
  <br>
<b>Способы модификации строк  </b><br>
	  <b><i>Индексы </i></b>- [01234...]  <br>
		&emsp;- s[len(s) - 1] - вывод последнего символа произвольной длины;   <br>
		&emsp;- s[-1] - последний символ из строки ; <br>
		&emsp;- s[-2] - предследний символ из строки . <br>
	<b><i>Срез строки: </i></b> <br>
		&emsp;- [start : stop] - интервал индексов ; <br>
		&emsp;- [start: ] - от указанного индекса и до конца строки ; <br>
		&emsp;- [ :stop] - от начала до указанного индекса ; <br>
		&emsp;- [:] - вся строка ; <br>
		&emsp;- [start : -stop] - от положительного и до отрицательного индекса, который не включен ; <br>
		&emsp;- [start : stop : step] - step - шаг - изначально =1 ; <br>
		&emsp;- [start : : step] - от начала с определенным шагом до конца строки ; <br>
		&emsp;- [ : stop : step] - до индекса с шагом ; <br>
		&emsp;- [ : : step] - от начала до конца строки с определенным шагом : <br>
		      	      &emsp;&emsp;&emsp;- [ : : -1] - вся строка наоборот ;  <br>
		      	      &emsp;&emsp;&emsp;- [ : : -2] - вся строка наоборот через один символ . <br>
</p> 

<h4>Форматирование строк</h4>
	<p>Метод:  <br>
		<b><i>- .format()</i></b> - возвращает новую строку, отформатированную по шаблону:  <br>
		<hr>
<pre>
    name = 0 (=index) *age = 1 (=index)
    name = Яна 
    age = 25
    message = 'Меня зовут {0}, мне {1} лет и я люблю Пайтон'.format(name, age)
    	ИЛИ 
    с помощью ключей:
    message = 'Меня зовут {fio}, мне {old} лет и я люблю Пайтон'.format(fio=name, old=age)</pre> 
	<hr><br>
		 <b><i>- f-строки</i></b>   <br>
		 	* f"..."  <br>
<pre>message = f'Меня зовут {name}, мне {age} лет и я люблю Пайтон'
message = f'Меня зовут {name.upper()}, мне {age * 2} лет и я люблю Пайтон'</pre> <br>
&emsp;&emsp; <b>СПЕЦ.СИМВОЛЫ </b> <br>
	Чтобы избежать экранирования; чтобы спец символы в строке НЕ воспринимались как СПЕЦ символы, надо использовать:  <br>
		&emsp;<b><i>- raw - строку </i></b>
		<pre><hr>&emsp;&emsp;* path = r"D:\\Python\\Projects..." -- D:\\Python\\Projects...</pre>
		&emsp;&emsp;* полезно для обозначения пути к файлам * <hr>
</p>


          <h2>2. Списки</h2>

          <h3>Определение Списков. Создание</h3>
<p>&emsp;<b><i>СПИСОК </i></b>- список[индекс] - упорядоченная ИЗМЕНЯЕМАЯ коллекция данных: <br>
		- динамическая структура данных, которая может меняться в процессе работы программы; <br>
		- объектами списков могут быть ЛЮБЫЕ типы данных. <br>
	&emsp;<b><i>list</i></b> - функция, может формировать новые списки на основе перебираемых объектов - пербирает все элементы списка:  
<pre><hr> b = list([True, False]) -- [True, False]
list('python') -- ['p', 'y', 't', 'h', 'o', 'n'] <hr></pre> </p>



          <h3>Методы Строк. Срезы</h3>
<p>
<b><i>Срезы списков</i></b>  <br>
		- список[start : stop] по индексам : <br>
		&emsp;* чтобы создать копию списка надо новой переменной присвоить значения изначального списка с пустым срезом [:] :
<br>cities = lst[:]*<br>
		- список[start : stop : step] по индексам:  <br>
		&emsp;- так как Списки - это изменяемый тип данных, то элементы спиcков можно перезапысывать: <br>
&emsp;&emsp;marks[2:4] = ['хорошо','удовлетворительно'] -- [2,3,'хорошо','удовлетворительно',5,2] -- замена по индексам; <br>
&emsp;&emsp;marks[2:4] = 10, 20 -- [2,3,10,20,5,2] -- замена по индексам.<br>
		Сравнение списков:  <br>
&emsp;[1, 2, 3] == [1, 2, 3] -- True   <br>
&emsp;[1, 2, 3] != [1, 2, 3] -- False  <br>
&emsp;[10, 2, 3] &gt; [1, 2, 3] -- True елементы списков сравниваются по местам  <br>
&emsp;[1, 2, 3] &lt;= [1, 2, 3] -- True  <br>
&emsp;[1, 2, 3, 4] &gt; [1, 2, 3] -- True  <br>
&emsp;[1, 2, 3, 'a'] &gt; [1, 2, 'a'] -- False  <br>
	<b><i>Методы списков: </i></b> <br>
		<b>Объект.Метод(Аргументы):</b>  <br>
			<b><i>- list.append()</i></b> - добавление элемента в конец списка (МЕНЯЕТ САМ, без присваивания через переменную):  <br>
				&emsp;&emsp;&emsp;* арг - True, вложенные списки итд, НО принимает только один аргумент*.  <br>
			<b><i>- .insert(индекс, замена элемента)</i></b> - позволяет вставлять в список в определенную позицию определенные значения. <br>
			<b><i>- .remove()</i></b> - позволяет удалять по ЗНАЧЕНИЮ элемента, удалит первое совпадение. <br>
			<b><i>- .pop(индекс)</i></b> - удаляет элемент по ИНДЕКСУ : <br>
				    &emsp;&emsp;&emsp;* без аргументов - удаляет последний элемент списка*.  <br>
			<b><i>- .clear()</i></b> - очищает весь список;  <br>
			<b><i>- .copy() </i></b>- возвращает копию списка (с присваиванием значения списка переменной):  <br>
				&emsp;&emsp;&emsp;*АНАЛОГ cities = lst[:] или с = lst(cities)*;  <br>
		<b><i> .count()</i></b>- - позволяет найти число элементов с указанным значением.  <br>
			<b><i>- .index(значение, start)</i></b> - позволяет найти индекс (первого найденного) определенного значения.  <br>
			<b><i>- .reversed()</i></b> - меняет порядок элементов следования на обратный.  <br>
			<b><i> .sort()</i></b>- - сортировка значений по возрастанию ( или неубыванию) текущего списка:  <br>
				&emsp;&emsp;&emsp;* без присваивания через переменную *<br>
				&emsp;&emsp;&emsp;* .sort(reverse=True) - отсортированный список в обратном порядке * <br>
</p>



          <h3>Поиск элемента. Операторы</h3>
<p>
	<b><i>Функции:  </i></b> <br>
		&emsp;- sum() - для вычисления суммы. <br>
		&emsp;- len() - определение числа элементов в списке(длина списка).  <br>
		&emsp;- max() - нахождение максимального значения.  <br>
		&emsp;- min() - нахождение минимального значения.  <br>
		&emsp;&emsp;* чтобы сохранить новое значение списка, надо присвоить его новой переменной*  <br>
		&emsp;- sorted() - для сортировки коллекции : <br>
			&emsp;&emsp;t = [...] ; <br>
			&emsp;&emsp;t_sort = sorted(t) - присваивание переменной значения элементов списка, идущего ПО ВОЗРАСТАНИЮ ; <br>
			&emsp;&emsp;t_sort = sorted(t, reversed=True) - значение списка, идущего ПО УБЫВАНИЮ. <br>
	<b><i>Операции: </i></b><br>
		+ -- соединение двух списков в один:  <br>
			&emsp;&emsp;[1, 2, 3] + [4, 5] -- [1, 2, 3, 4, 5]  <br>
			&emsp;&emsp;[1, 2, 3] + [4] -- [1, 2, 3, 4]  <br>
			&emsp;&emsp;[1, 2, 3] + [True] -- [1, 2, 3, True]  <br>
		* -- дублирование списка:  <br>
			&emsp;&emsp;['1', '2', '3'] * 3 -- ['1', '2', '3', '1', '2', '3', '1', '2', '3']  <br>
			&emsp;&emsp;['1'] + ['2'] * 3 + ['3'] -- ['1', '2', '2', '2', '3']  <br>
		in - проверка вхождения элемента в список:  <br>
			&emsp;&emsp;lst = [1, 2, 3] -- 2 in lst -- True  <br>
			&emsp;&emsp;                -- [4, 5] in lst -- False   --  то есть lst = [1, 2, 3, [4, 5]] ?  <br>
		del - удаление элемента из списка по индексу:  <br>
			&emsp;&emsp;del lst[2] -- [1, 2]  <br>
          <br>
	<b><i>Вложенные списки: </i></b> <br>
		&emsp;&emsp;line = [1, 2, 3, 4, 5]  <br>
		  &emsp;&emsp;img = [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]  <br>
		  	&emsp;&emsp;&emsp;ИЛИ  <br>
		  &emsp;&emsp;img = [line[:], line[:], line[:]]  <br>
		- обращение к определенному элементу списка:  <br>
			&emsp;&emsp;img [0][1] - img [0 - индекс вложенного списка] [1 - индекс элемента во вложенном списке]  <br>
		- замена элементов во вложенном списке:  <br>
			&emsp;&emsp;img[1] = [0, 0, 0, 0, 0] (формирование нового списка)  ИЛИ img[1] = [0] * 5 (замена значений)  <br>
			&emsp;&emsp;&emsp;-- [[1, 2, 3, 4, 5], [0, 0, 0, 0, 0], [1, 2, 3, 4, 5]]  <br>
			&emsp;&emsp;img[1][:] = [1] * 5  <br>
			&emsp;&emsp;&emsp;-- [[1, 2, 3, 4, 5], [1, 1, 1, 1, 1], [1, 2, 3, 4, 5]]  <br></p>



          <h3>Генератор списков</h3>
          <p><b>[&lt;способ формирования значения&gt; for &lt;переменная&gt; in &lt;итерируемый объект&gt;] </b> <br>
	&emsp;- переменная доступна только в самом генераторе цикла:  <br>
	&emsp;&emsp;&emsp;a = [d for d in "python"] -- a = ['p', 'y', 't', 'h', 'o', 'n']  <br>
	&emsp;&emsp;&emsp;a = [len(d) for d in t]  <br>
	&emsp;&emsp;&emsp;a = [x for x in range(-5, 5) if x % 2 == 0] -- a= [-4, -2, 0, 2, 4]  <br>
	&emsp;&emsp;&emsp;a = [x for x in range(-6, 7) if x % 2 == 0 and x % 3 == 0] -- a= [-6, 0, 6]  <br>
	&emsp;&emsp;&emsp;a = [city for city in cities if len(city) &lt; 7] -- a= ['Москва', 'Тверь', 'Рязань']  <br>
		- Генератор списков с вложенным тернарным оператором:  <br>
			&emsp;&emsp;&emsp;d = [4, 3, -5, 0, 2, 11, 122, -8, 9]  <br>
			&emsp;&emsp;&emsp;a = ["четное" if x % 2 == 0 else "нечетное" for x in d]  <br>
			&emsp;&emsp;&emsp;print(a)  <br>
			&emsp;&emsp;&emsp;&emsp;&emsp;ИЛИ  <br>
			&emsp;&emsp;&emsp;a = ["четное" if x % 2 == 0 else "нечетное"   <br>
			&emsp;&emsp;&emsp;for x in d  <br>
			&emsp;&emsp;&emsp;if x &gt; 0  <br>
			&emsp;&emsp;&emsp;]  <br>
			&emsp;&emsp;&emsp;print(a)  <br>
			&emsp;&emsp;&emsp;   --- ['четное', 'нечетное', 'четное', 'нечетное', 'четное', 'нечетное']  <br>
<b><i>ВЛОЖЕННЫЕ генераторы списков:</i></b>  <br>
	1. <b>[&lt;способ формирования значения&gt;  <br>
	   &emsp;for &lt;переменная&gt; in &lt;итерируемый объект&gt; if &lt;условие&gt;  <br>
	   &emsp;for &lt;переменная&gt; in &lt;итерируемый объект&gt; if &lt;условие&gt;  <br>
	   &emsp;for &lt;переменная&gt; in &lt;итерируемый объект&gt; if &lt;условие&gt;  <br>
	   &emsp;...  <br>
	   &emsp;]  <br></b>
		&emsp;&emsp;*каждый последующий цикл является вложенным в другой * <br>
		&emsp;&emsp;* if &lt;условие&gt; - необязательно*  <br>
	2. <b>[&lt;оператор&gt; for &lt;счетчик&gt; in &lt;итерируемый объект&gt;] --  <br>
	    &emsp;-- [ [генератор списка]   <br>
	       &emsp;&emsp;for &lt;переменная&gt; in &lt;итерируемый объект&gt;  <br>
	       &emsp;&emsp;]  <br></b>
	  code:  <br>
	  M, N = 3, 4  <br>
	  matrix = [[a for a in range(M)] for b in range(N)]  <br>
	  print(matrix) -- [[0,1,2], [0,1,2], [0,1,2]]  <br>
	  	&emsp;* for b in range(N) -- это внешний цикл * <br>
	  	&emsp;* b=0 (как индекс) -- переход во внутренний цикл и формирование знчений [0,1,2] * <br>
	  	&emsp;* b=1 (как индекс) -- переход во внутренний цикл и формирование знчений [0,1,2] * <br>
	  	&emsp;* b=2 (как индекс) -- переход во внутренний цикл и формирование знчений [0,1,2] * <br>
	  	&emsp;* print(matrix) -- вывод полного списка со вложенными списками * <br>
3. <i>ОТЛИЧИЕ ВЛОЖЕННОГО ГЕНЕРАТОРА СПИСКА ОТ ОБЫЧНОГО:	 </i> <br>
	  A = [[1,2,3],[4,5,6],[7,8,9]]  <br>
	  	&emsp;3.1. ВЛОЖЕННЫЙ:  <br>
	  		&emsp;&emsp;AA = [[x**2 for x in row] for row in A]  --- [[1,4,9],[16,25,36],[49,64,81]]  <br>
	  	&emsp;3.2. НЕ ВЛОЖЕННЫЙ:  <br>
	  		&emsp;&emsp;a = [x**2   <br>
	       		    &emsp;&emsp;&emsp;for row in A  <br>
	       	            &emsp;&emsp;&emsp;&emsp;for x in row  <br>
	                    &emsp;&emsp;&emsp;&emsp;]  <br>
	                    &emsp;&emsp;&emsp;&emsp;--- [1,4,9,16,25,36,49,64,81]  <br></p>
        </section>


        <section id="python-collections">
          <h2>5. Кортежи, Множества, Словари</h2>
          <h2>1. Кортежи</h2>
          <h3>Определение Кортежа</h3>
<p>SYNTAX: tuple(любой итерируемый объект) <br>
	<b><i>КОРТЕЖИ </i></b>- tuple - () - это упорядоченная, но НЕИЗМЕНЯЕМАЯ коллекция произвольных данных:  <br>
	 	&emsp;* создание кортежа либо a = 1,2, либо a = (1,2) *<br>
	 	&emsp;* создание кортежа с 1 элементом -- a = 1, , либо a = (1,) *<br>
	 - <b><i>Синтаксис множественного присваивания</i></b>(можно делать с любыми итерируемыми объектами): <br>
	 	&emsp;* если есть кортеж, то его можно РАСПАКОВАТЬ в переменные: x, y = (1, 2) или x, y = 1, 2 *<br>
	 	&emsp; x, y = ['hello', 'python'] -- x = 'hello' , y = 'python' <br>
	 	&emsp; a, b = 'ra' -- a = 'r' , b = 'a' <br>
	 - Количество элементов кортежа -- len(a); <br>
	 - К элементам кортежа можно обратиться через ИНДЕКС : a[0] -- 1; <br>
	 - Обращение через СРЕЗЫ: a[1:2] -- (2,); <br>
	 - Когда мы берем полный срез кортежа - КОПИЯ кортежа НЕ создается (у переменных ОДИНАКОВЫЙ id):  <br>
	    &emsp;*в случае СРЕЗА СПИСКА [:] создается КОПИЯ (у переменных РАЗНЫЙ id)*  <br>
	 	&emsp;b = a[:] - b ссылается на тот же самый кортеж, что и а <br>
	 У списков больше функциональности, чем у кортежей, но: <br>
	 	&emsp;1. кортежи используются, когда мы хотим запретить программисту менять значение элементов; <br>
	 	&emsp;2. кортежи можно использовать в качестве Ключей у словарей: <br>
	 		&emsp;&emsp;d={} <br>
	 		&emsp;&emsp;d[a] = 'кортеж' <br>
	 		&emsp;&emsp;d -- {(1, 2) : 'кортеж'} <br>
	 	&emsp;3. кортежи занимают меньше памяти, чем списки. <br>
	 Если мы работаем с упорядоченным неизменяемым списком, то ПРЕДПОЧТИТЕЛЬНЕЕ использовать кортежи.  <br>
</p>
 <h3>Применение и особенности. Методы</h3>
 <p>
	+ - Чтобы ДОБАВЛЯТЬ элементы в кортеж, используется такой метод:  <br>
	 	&emsp;a = () # создание пустого кортежа или например b = tuple()  <br>
	 	&emsp;a = a + (1,) -- a -- (1,) -- краткая запись a += (.. ,)  <br>
	 	&emsp;a = (2, 3) + a -- a -- (2, 3, 1)  <br>
	 	&emsp;a += (('a', 'hello'),) -- a -- (2, 3, 1, ('a', 'hello'))  <br>
	* - Чтобы ПРОДУБЛИРОВАТЬ кортеж:  <br>
		&emsp;b = (0,) * 10 -- b -- (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)  <br>
		&emsp;b = ('hello', 'world') * 2 -- b -- ('hello', 'world', 'hello', 'world')  <br>
	В кортежах НЕЛЬЗЯ УДАЛЯТЬ УЖЕ существующие элементы.  <br>
	&emsp;- Список в Кортеж:   <br>
		&emsp;&emsp;&emsp;a = tuple([1, 2, 3]) -- a -- (1, 2, 3)  <br>
	&emsp;- Кортеж в Список:   <br>
		&emsp;&emsp;&emsp;t = (1, 2, 3)  <br>
		&emsp;&emsp;&emsp;list(t) -- [1, 2, 3]  <br>
	&emsp;- Строка в Кортеж:  <br>
		&emsp;&emsp;&emsp;a = tuple('hello') -- a -- ('h', 'e', 'l', 'l', 'o')  <br>
	&emsp;- Изменяемые типы данных ВНУТРИ кортежа мы МОЖЕМ менять:  <br>
		&emsp;&emsp;&emsp;a = (True, [1,2,3], 'hello', 5, {'house' : 'дом'})  <br>
		&emsp;&emsp;&emsp;a[1] -- #индекс -- [1,2,3]  <br>
		&emsp;&emsp;&emsp;a[1].append('5') -- a -- (True, [1,2,3, '5'], 'hello', 5, {'house' : 'дом'})  <br>
	&emsp;- Проверка вхождения значения в кортеж:  <br>
		&emsp;&emsp;&emsp;3 in a -- False  <br>
		&emsp;&emsp;&emsp;[1, 2] in a -- True  <br>
<b><i>Методы кортежей:  </i></b><br>
	<b><i>- tuple.count(значение)</i></b> - возвращает число найденных элементов с указанным значением: <br>
		&emsp;&emsp;a = ('abc', 2, [1, 2], True, 2, 5)  <br>
		&emsp;&emsp;a.count('abc') -- 1  #количество  <br>
		&emsp;&emsp;a.count(2) -- 2  #количество  <br>
	<b><i>- tuple.index(значение[, start[, stop]])</i></b>- - возвращает индекс первого найденного элемента с указанным значением:  <br>
		&emsp;&emsp;a.index(2) -- 1  #индекс первого совпадения  <br>
		&emsp;&emsp;a.index(2, 2) -- 4  #index(2 - значение, 2 - стартовый индекс)   <br>
		&emsp;&emsp;a.index(2, 2, 5) -- 4  #index(2 - значение, 2 - стартовый индекс, 5 - конечный индекс (не вкл))   <br>
</p>




          <h2>2. Множества</h2>
          <h3>Определение Множеств</h3>
<p>&emsp;<b><i>МНОЖЕСТВА</i></b> - set() - это НЕупорядоченная Итерируемая ИЗМЕНЯЕМАЯ коллекция УНИКАЛЬНЫХ элементов:  <br>
		&emsp;&emsp;a = {1, 2, 3, 'hello'}   <br> </p>

        <h4>Особенности</h4>
	<p>&emsp;*Как в словарях фигурный скобки, но Отличие в том, что в множествах нет Ключей * <br>
	&emsp;* в множествах используются только НЕИЗМЕНЯЙМЕ ТИПЫ ДАННЫХ (числа, булевы значения, строки, кортежи(в кортежах тоже неизменяемые типы))*  <br>
	&emsp;* НЕЛЬЗЯ использовать ИЗМЕНЯЕМЫЕ типы данных(списки, словари, другие множества)*  <br>
	&emsp;* внутри множеств НЕЛЬЗЯ использовать другие МНОЖЕСТВА*  <br>
	&emsp;* для создания ПУСТОГО МНОЖЕСТВА используется функция set() *  <br>
	&emsp;&emsp;set([1, 2, 0, -1, -1, 2]) -- {1, 2, 0, -1}  <br>
	&emsp;&emsp;set('abracadabra') -- {'d', 'k', 'a', 'b', 'r'}  <br>
	&emsp;&emsp;set(range(7)) -- {0, 1, 2, 3, 4, 5, 6}  <br>
	&emsp;* так как множетсва это НЕУПОРЯДОЧЕННАЯ коллекция, то к элементам НЕЛЬЗЯ обратиться по индексам * <br>
	&emsp;* Множества могут УБИРАТЬ ДУБЛИ из коллекции *  <br>
	- Множество в Список:  <br>
		&emsp;&emsp;list(set(cities)) -- [...]  <br>
	- Чтобы перебрать элементы:  <br>
		&emsp;&emsp;&emsp;q = set(cities)  <br>
		&emsp;&emsp;&emsp;for c in q:  <br>
		&emsp;&emsp;&emsp;&emsp;print(c)  <br>
		&emsp;&emsp;&emsp;&emsp;ИЛИ  <br>
		&emsp;&emsp;&emsp;it = iter(q)  <br>
		&emsp;&emsp;&emsp;next(it) ...  <br>
	* Количество элементов множества: len(q)*  <br>
	* Определить наличие элемента: 'Moscow' in q -- True * <br>

    <h4>Методы множеств</h4> <p>
	<b><i>- .add()</i></b> - Добавление ОДНОГО элемента в пустое множество:  <br>
		&emsp;&emsp;b = set() #создание пустого множества  <br>
		&emsp;&emsp;b.add(7) -- b = {7}  <br>
		&emsp;&emsp;b.add(3) -- b = {3, 7}  <br>
	<b><i>- .update(любой итерируемый объект)</i></b>- - Добавление НЕСКОЛЬКИХ элементов в пустое множество:  <br>
		&emsp;&emsp;b.update(['a', 'b', (1,2)]) -- b = {(1,2), 3, 7, 'a', 'b'}  <br>
		&emsp;&emsp;b.update(['abc', (1,2)]) -- b = {(1,2), 3, 7, 'a', 'b', 'c'}  <br>
	<b><i>- .discard(удаляемое значение)</i></b> - Удаление значения, не возвращает ошибки при несуществующем значении;  <br>
	<b><i>- .remove(удаляемое значение)</i></b> - Удаление значения, но если указать несуществующее значение - выведет критическую ошибку; <br>
	<b><i>- .pop()</i></b> - удаляет произвольный(рандомный) элемент(pop без аргумента), возвращает удаленное значение;  <br>
	<b><i>- .clear() </i></b>- Удаляет все элементы. <br> </p>

<h4>Операции над Множествами</h4>
	<p>setA = {1,2,3,4}  <br>
	setB = {3,4,5,6,7}  <br>
	&emsp; <b><i>setA & setB - Операция пересечения</i></b> - res = {3,4} -  <br>
		&emsp;&emsp;- setA &= setB (== setA = setA & setB) - форма сохранения результата в setA = {3,4}  <br>
		&emsp;&emsp;&emsp;*АНАЛОГ setA.intersection(setB) -- {3,4} -  возвращает результат * <br>
		&emsp;&emsp;*чтобы сохранить результат в setA, надо написать метод:  <br>
		&emsp;&emsp;&emsp;setA.intersection_update(setB) -- setA = {3,4}*  <br>
	&emsp;<b><i>setA | setB - Операция объединения </i></b>- res = {1,2,3,4,5,6,7}  <br>
		&emsp;&emsp;- setA |= setB (== setA = setA | setB) - форма сохранения результата в setA = {1,2,3,4,5,6,7}  <br>
		&emsp;&emsp;&emsp;*АНАЛОГ setA.union(setB) -- {3,4} -  возвращает результат * <br>
	&emsp;<b><i>setA - setB - Операция вычитания</i></b> - res = {1,2,3,4,5,6,7}  <br>
	&emsp;<b><i>Разность (операция вычитания):</i></b>  <br>
		&emsp;&emsp;- setA - setB -- res = {1,2} -- остаются значения setA --   <br>
			&emsp;&emsp;&emsp;*setA -= setB (== setA = setA - setB) - форма сохранения результата в setA = {1,2} * <br>
		&emsp;&emsp;- setB - setA -- res = {5,6,7} -- остаются значения setB  <br>
			&emsp;&emsp;&emsp;*setA -= setB (== setB = setB - setA) - форма сохранения результата в setB = {5,6,7} * <br>
	&emsp;<b><i>setA ^ setB - Операция семмитричной разности</i></b> - res = {1,2,5,6,7}   <br>
		&emsp;&emsp;*остаются уникальные элементы обоих множеств, общие элементы исключаются*  <br>
	&emsp;<b><i>setA == setB - Операция сравнения -</i></b>   <br>
		&emsp;&emsp;setA = {7,6,5,4,3}  <br>
		&emsp;&emsp;setB = {3,4,5,6,7}  <br>
		&emsp;&emsp;&emsp;- res = True - если совпадает количество элементов и их значения  <br>
	&emsp;<b><i>setA != setB - Операция неравенства </i></b>- res = False  <br>
	&emsp;<b><i>setA &gt; setB - Операция сравнения - </i></b>  <br>
		&emsp;&emsp;setA = {7,6,5,4,3}  <br>
		&emsp;&emsp;setB = {3,4,5}  <br>
		&emsp;&emsp;&emsp;- res = True - так как множество setB входит в множество setA  <br>
	&emsp;setB.add(22) --  <br>
		&emsp;&emsp;setA &gt; setB -- False  <br>
		&emsp;&emsp;setA &lt; setB -- False  <br>
		&emsp;&emsp;&emsp;- так как ни одно из множеств не входит в другое  <br>
	&emsp;setA &lt;= setB --   <br>
		&emsp;&emsp;setA = {7,6,5,4,3}  <br>
		&emsp;&emsp;setB = {3,4,5,6,7}  <br>
		&emsp;&emsp;&emsp;- res = True - срабатывает оператор =  <br>
</p>

     
          <h2>3. Словари</h2>
           <h3>Определение Словарей</h3>
<p>&emsp;<b><i>СЛОВАРИ </i></b> - (dict) - упорядоченные коллекции. <br>
    SYNTAX: d = {key1 : value1, key2 : value2,...}  <br>
    d = {'house':'дом', 'car':'машина', 'tree':'дерево',...}	  <br>
	&emsp;<b><i>- Ключ </i></b>- ТОЛЬКО НЕИЗМЕНЯЕМЫЙ тип данных;  <br>
    &emsp;<b><i>- Значение</i></b> - ЛЮБОЙ тип данных.  <br>
    * ключ ссылается на одно значение, на два и более ссылаться не может*  <br>
	 		* чтобы обратиться к значению, надо обратиться через ключ:  <br>
	  		&emsp;&emsp;d = ['house'] -- 'дом'  *<br>
	  		
	- dict() - создание словаря через функцию:  <br>
		&emsp;&emsp;dict(key1 = value1, key2 = value2,..)  <br>
			* ключи должны быть строками и записываться без кавычек, например:  <br>
				&emsp;&emsp;dict(one=1, two=2, three='3') -- {'one':'1', 'two':'2', 'three':'3'} * <br>
			* может быть полезно когда из списка нужно сделать словарь:  <br>
				&emsp;&emsp;lst = [[4, 'хорошо'], [5, 'отлично']]   (в качестве ключа могут быть любые типы данных)  <br>
				&emsp;&emsp;dict(lst) -- {4 : хорошо, 5 : отлично} * <br>
			* для вызова пустого словаря: dict() / {} * <br>
			* ПРИСВАИВАНИЕ КЛЮЧУ ЗНАЧЕНИЕ (Ключи - любые НЕИЗМЕНЯЕМЫE ТИПЫ данных):  <br>
				&emsp;&emsp;d[True] = "Истина" -- {True : "Истина"}  <br>
				&emsp;&emsp;d[False] = "Ложь" -- {True : "Истина", False : "Ложь"} * <br>
		  	*чтобы изменить значение у существующего ключа:  <br>
		  		&emsp;&emsp;d[True] = 1 -- {True : 1, False : "Ложь"} * <br>
		  	* Ключ не может быть списком, потому что список это ИЗМЕНЯЕМЫЙ тип данных:  <br>
		  		&emsp;&emsp;d[[1,2]] = 1 -- Error * <br>
		  	* Значение - ЛЮБОЙ тип данных  <br>
		  		&emsp;&emsp;d = {True : 1, False : "Ложь", 'list' : [1,2], 5 : 5} - OK  *<br>
		  	* ДЛИНА списка : len(d) -- выводит количество ключей * <br>
		  	* УДАЛЕНИЕ ключа: del d[True] * <br>
		  	* Проверка НАЛИЧИЯ КЛЮЧА: "abc" in d -- True/Falses * <br>
		  	* Проверка ОТСУТСТВИЯ КЛЮЧА: "abc" not in d -- True/Falses * <br>
<h4>Методы словарей</h4> <p>
	<b><i>- dict.fromkeys(список[, значение по умолчанию]])</i></b> - формирует словарь с заданными ключами, ключи передаются в виде списка, и некоторым значением:  <br>
		&emsp;&emsp;lst = ['+7', '+6', '+5']  <br>
		&emsp;&emsp;a = dict.fromkeys(lst) -- {'+7': None, '+6': None, '+5': None}	  <br>
		&emsp;&emsp;a = dict.fromkeys(lst, 'country') -- {'+7': 'country', '+6': 'country', '+5': 'country'}	  <br>
	<b><i>- .clear()</i></b> - для очистки словаря -- {}  <br>
	<b><i>- .copy()</i></b>- - создание копии словаря:  <br>
		&emsp;&emsp;d = {True : 1, False : "Ложь", 'list' : [1,2], 5 : 5}  <br>
		&emsp;&emsp;d2 = d.copy()  <br>
		&emsp;&emsp;/  <br>
		&emsp;&emsp;d2['list'] = [5,6] ---- d2 = {True : 1, False : "Ложь", 'list' : [5,6], 5 : 5}  <br>
		&emsp;&emsp;исходный список d не меняется , изменения в копии d2  <br>
	<b><i>- dict()</i></b> для создания копии:  <br>
		&emsp;&emsp;d2 = dict(d)  <br>
	<b><i>- .get(ключ, (если ключ не возвращает значение - прописывается обозначение отсутствия))</i></b> - получение значения:  <br>
		&emsp;&emsp;d.get("list")  <br>
			&emsp;&emsp;&emsp;* отличие от способа получения занчения через d['list'] --[1,2]:  <br>
				&emsp;&emsp;&emsp;&emsp;d[3] -- Error  <br>
				&emsp;&emsp;&emsp;&emsp;d.get(3) - OK * <br>
			&emsp;&emsp;&emsp;* d.get(3, False) -- False (ключа 3 нет)*  <br>
	<b><i>- dict.setdefault(key[,default])</i></b> - возращает значение по заданному ключу, но если ключа нет, то создается запись в словаре с этим несуществующим ключом и некоторым значением по умолчанию или тем, который мы укажем в качестве аргумента:  <br>
		&emsp;&emsp;* (ключа 3 нет в списке):  <br>
			&emsp;&emsp;&emsp;d.setdefault(3) -- None -- {True : 1, False : "Ложь", 'list' : [5,6], 5 : 5, 3 : None}  <br>
			&emsp;&emsp;&emsp;d.setdefault(3, three) -- 'three' -- {True : 1, False : "Ложь", 'list' : [5,6], 5 : 5, 3 : 'three'}*  <br>
		&emsp;&emsp;* если ключ есть - возвращает значение * <br>
	<b><i>- .pop(ключ)</i></b> - удаление ключа вместе со значением. Возвращает содержимое удаляемого ключа:  <br>
		&emsp;d.pop(3) -- 'three' -- {True : 1, False : "Ложь", 'list' : [5,6], 5 : 5}  <br>
		&emsp;&emsp;* если ключа в словаре нет, то второй аргумент - это что поставить для обозначения ошибки:  <br>
			&emsp;&emsp;&emsp;d.pop('abc', False) -- False * <br>
	<b><i>- .popitem()</i></b> - удаляет случайно выбранный ключ (обычно последний):  <br>
		&emsp;d.popitem() -- (5(ключ), 5(значение)) -- {True : 1, False : "Ложь", 'list' : [5,6]}  <br>
	<b><i>- .keys()</i></b> - возвращает список ключей:  <br>
		&emsp;d = {True : 1, False : "Ложь", 'list' : [1,2], 5 : 5}  <br>
		&emsp;d.keys() -- dict_keys([True, False, 'list', 5])  <br>
			&emsp;&emsp;* цикл for проходит по ключам:  <br>
				&emsp;&emsp;&emsp;for x in d:  <br>
				&emsp;&emsp;&emsp;print(x) --- True, False, 'list', 5 * <br>
	<b><i>- .values()</i></b> - возвращает список значений:  <br>
		&emsp;d.values() -- dict_values([1, 'Ложь', [1,2], 5])  <br>
			&emsp;&emsp;* цикл for проходит по значениям:  <br>
				&emsp;&emsp;&emsp;for x in d.values():  <br>
				&emsp;&emsp;&emsp;print(x) --- 1, 'Ложь', [1,2], 5 * <br>
	<b><i>- .items()</i></b> - возвращает список ключей и значений:  <br>
		&emsp;d.items() -- dict_items([(True, 1), (False, "Ложь"), ('list', [1,2]), (5, 5)]):  <br>
			&emsp;&emsp;* цикл for проходит по ключам и значениям:  <br>
				&emsp;&emsp;&emsp;for x in d.items():  <br>
				&emsp;&emsp;&emsp;print(x) --- (True, 1), (False, "Ложь"), ('list', [1,2]), (5, 5) - КОРТЕЖ * <br>
			&emsp;&emsp;*множественное присваивание через цикл for:  <br>
				&emsp;&emsp;&emsp;for key, value in d.items():  <br>
				&emsp;&emsp;&emsp;print(key, value) --- True 1, False "Ложь", 'list' [1,2], 5, 5 * <br>
	<b><i>- .update(dict)</i></b> - соединяет/обновляет два словаря :  <br>
			&emsp;&emsp;* в первом словаре по СОВПАДАЮЩИМ ключам обновляет значения на значения второго словаря * <br>
			&emsp;&emsp;* НЕсовпадающие ключи и их значения добавляет после совпадающих Образуя ЕДИНЫЙ словарь * <br>
			&emsp;&emsp;&emsp;АНАЛОГ:  <br>
			&emsp;&emsp;d3 = {**d, **d2}  // d.update(d2) // d | d2 * <br>
			&emsp;*если поменять словари местами, то значения совпадающих ключей поменяются:  <br>
			&emsp;&emsp;d3 = {**d2, **d} // d2.update(d) // d2 | d * <br>
	</p>


         
         
         
        </section>



        <section id="python-function">
          <h2>6. Функции</h2>
          <h3>Определение Функции</h3>
          <p>&emsp;<b><i>ФУНКЦИИ </i></b>- это именованный блок кода,
 который выполняет определённую задачу и
 может быть вызван из других частей программы. <br>
            &emsp;SYNTAX:   <br>
		def &lt;имя функции&gt; ([список аргументов]):  <br>
			&emsp;оператор 1  <br>
			&emsp;оператор 2...  <br>
            <br>
	&lt;имя функции&gt; - обозначается через глагол	  <br>	
	имя объекта --&gt; объект функционирования  <br>
	    - Функции, в первую очередь существуют, чтобы устранять дублирование кода  <br>
	    &emsp;!! print - сама функция - это просто ссылка на функцию,  <br>
	    &emsp;- чтобы ее активировать/запустить необходимо после имени этой функции поставить оператор ()  <br>
		    &emsp;&emsp;&emsp;* f = print -- f()  <br>
		    &emsp;&emsp;&emsp;f('hello') -- hello  <br>
		&emsp;* имени print можем присвоить любой другой объект:  <br>
			&emsp;&emsp;&emsp;print = 'это была функция принт'   <br>
			&emsp;&emsp;&emsp;f(print) -- это была функция принт  *<br> </p>
<h3>Переменные в функциях</h3>
          <p>
<b><i>Переменные: </i></b><br>
- <i>Локальные</i> - существуют только внутри функции. <br>
- <i>Глобальные</i> - определяются вне функций и доступны во всем модуле кода. <br>
<b><i>Параметр: </i></b><br>
- <i>Фактический</i> - параметр, который НЕ имеет изначальных значений <br>
- <i>Формальный</i> - параметр, который СРАЗУ принимает определенные значения <br>
<b><i>Аргумент: </i></b><br>
- <i>Позиционный </i>- значение передается по ПОЗИЦИИ при вызове функции <br>
- <i>Именной</i> - значение передается по ИМЕНИ при вызове функции <br>
</p>
            <h4>Примеры</h4>
<p>(между объявлением функции и ее вызовом должно быть 2 ПРОБЕЛА)
	<hr><pre> #1
def send_mail():  
	&emsp;text = 'Что такое функция?'  
	&emsp;print(text)  
	  
	  
send_mail() -- можно вызывать несколько раз 
<hr>#2
// from_name - параметр  
// Иван Иванович - аргумент  
// 1 параметр - 1 аргумент 
def send_mail(from_name):  
	text = 'Что такое функция? Ваш навсегда {from_name}!'  
        print(text)  

send_mail('Иван Иванович') 
&emsp;&emsp;&emsp;-- Что такое функция? Ваш навсегда Иван Иванович! 
<hr>#3
(с 2 аргументами:) 
def send_mail(from_name, old): 
    text = 'Мне {old} лет! Что такое функция? Ваш навсегда {from_name}!' 
    print(text)


send_mail('Иван Иванович', 7) 
&emsp;&emsp;&emsp;-- Мне 7 лет! Что такое функция? Ваш навсегда Иван Иванович! 
<hr></pre></p>



<h3>Параметры, Аргументы, Оператор return. Встроенные функции</h3>
<p>
<b><i>Оператор RETURN </i></b> <br>
	&emsp;- res ссылается на результат 7.0(на объект)  <br>
	&emsp;- оператор return возвращает ссылку на этот объект  <br>
	&emsp;- то есть при вызове функция возвращает ссылку на объект содержащий значение 7  <br>
	&emsp;- когда переменной а присваивается числовое значение, то в программе создается переменная, и выводится в консоль  <br>
	&emsp;- то что возвращает оператоор return - возвращает и функция  <br>
<pre><hr><i>#1 - return пишется только 1 раз при завершении работы функции</i>
def get_sqrt(x):
	res = None if x&lt; 0 else x**0.5
	return res
		
a = get_sqrt(49)
print(a)

<hr><i>#2 - Возвращение 2х переменных с помощью Кортежа:</i>
def get_sqrt(x):
	res = None if x&lt; 0 else x**0.5
	return res, x
		
a, b = get_sqrt(49)
print(a, b)

<hr><i>#3 - Условие в RETURN</i>
def get_max(a, b):
	return a if a> b else b
		
x, y = 5, 7
print(get_max(x, y))

<hr><i>#4 - 2 Параметра, но надо сравнить 3 числа:</i>
def get_max2(a, b):
	return a if a> b else b
		
x, y, z = 5, 7, 10
print(get_max2(x, get_max(y, z))) 
        -- сначала посчитается вложенная функция, а потом ее результат сравнивается с х

<hr><i>#5 - АНАЛОГ (функциональный подход в программировании):</i>
def get_max3(a, b, c):
	return get_max2(a, get_max(b, c))
		
x, y, z = 5, 7, 10
print(get_max3(x, y, z))

<hr><i>#6 - Функция Вложенная в Условие:</i>
PERIMETR = True
if PERIMETR:
	def get_rect(a, b):
		return 2 * (a + b)
else: 
	def get_rect(a, b):
		return a * b
				
print(get_rect(1.5, 3.8))

<hr><i>#7 - Функция в Цикле:</i>
def even(x):
	return x % 2 == 0
		
for i in range(1, 20):
	if even(i):
		print(i)
<hr></pre></p>
          
          


          <h3>Рекурсия</h3>
          <p>&emsp;<b><i>Рекурсия в функциях</i></b> — это механизм, при котором функция вызывает сама себя
             (для решения подзадачи того же типа, но меньшего размера). <br>
&emsp;<b><i>Ключевые элементы: </i></b><br>
<b><i>- Базовый</i></b> случай (терминальное условие) — условие выхода из рекурсии. Без него функция будет вызывать себя бесконечно (переполнение стека); <br>
<b><i>- Рекурсивный</i></b> случай — вызов функции с изменёнными параметрами, приближающими к базовому случаю. <br>
<hr>Пример: вычисление факториала
<pre>
def factorial(n):
    if n == 0 or n == 1:  # базовый случай
        return 1
    else:                     # рекурсивный случай
        return n * factorial(n - 1) <hr></pre></p>
        
        </section>

        <section id="python-sort">
          <h2>7. Сортировка, Поиск</h2>
          <h2>1. Сортировка</h2>
<p><b><i>Сортировка</i></b> — упорядочивание элементов по возрастанию/убыванию по заданному критерию. <br></p>
          <h3>Оптимальность</h3>
<p><b><i>Эффективность алгоритма оценивают по:</i></b> <br>
&emsp;- Временной сложности (сколько операций нужно); <br>
&emsp;- Пространственной сложности (сколько памяти требуется); <br>
&emsp;- Устойчивости (сохраняет ли порядок равных элементов). <br>
Оптимальный алгоритм зависит от размера данных, их структуры и требований.</p>
<h3>Сложность</h3>
<p><b><i>O(n)</i></b> и другие обозначения вида O(…) — это нотация «О‑большое» (Big O), инструмент для оценки временной сложности алгоритмов. <br>
&emsp;Она показывает, как растёт время выполнения алгоритма при увеличении объёма входных данных (обозначаемого как n). <br>
<i>Нужно для предсказания производительности:</i> понять, как алгоритм будет работать на больших объёмах данных.</p>
<p>
* Нотация описывает худший случай (верхнюю границу).  <br>
    <b><i>Основные классы сложности (от лучшего к худшему):</i></b> <br>
<b>1. O(1) — константная сложность</b> <br>
&emsp;Время выполнения не зависит от размера данных. <br>
&emsp;Пример: доступ к элементу массива по индексу arr[5]. <br>
&emsp;Как бы ни рос n, операция выполняется за одно и то же время. <br>
<b>2. O(log n) — логарифмическая сложность</b> <br>
&emsp;Время растёт очень медленно с увеличением n. <br>
&emsp;Пример: бинарный поиск в отсортированном массиве. <br>
&emsp;Для массива из 1.000.000 элементов — всего ~20 проверок. <br>
<b>3. O(n) — линейная сложность</b>  <br>
&emsp;Время растёт пропорционально размеру данных.  <br>
&emsp;Пример: поиск минимального элемента в массиве (нужно проверить каждый).  <br>
&emsp;Если n увеличилось в 10 раз — время тоже вырастет в 10 раз.  <br>
<b>4. O(n log n) — линеарифмическая сложность</b>  <br>
&emsp;Медленнее линейного, но быстрее квадратичного.  <br>
&emsp;Пример: эффективная сортировка (слиянием, быстрая сортировка).  <br>
&emsp;Для n=1000 — примерно 10.000 операций.  <br>
<b>5. O(n²) — квадратичная сложность</b>  <br>
&emsp;Время растёт как квадрат размера данных.  <br>
&emsp;Пример: сортировка пузырьком, вложенные циклы по всем элементам.  <br>
&emsp;Для n=1000 — 1.000.000 операций (может быть медленно).  <br>
<b>6. O(2ⁿ) — экспоненциальная сложность</b>  <br>
&emsp;Время растёт катастрофически быстро.  <br>
&emsp;Пример: перебор всех подмножеств массива.  <br>
&emsp;Для n=30 — уже миллиарды операций.  <br>
<b>7. O(n!) — факториальная сложность</b>  <br>
&emsp;Самая медленная из распространённых.  <br>
&emsp;Пример: перебор всех перестановок элементов.  <br>
&emsp;Для n=10 — 3.628.800 операций.  <br>
</p>


          <h3>Сортировка Пузырьком (Bubble Sort)</h3>
<p><b><i>Как работает:</i></b> сравниваем соседние элементы и меняем их местами, если левый больше правого. Повторяем, пока массив не упорядочится.  <br>
<b><i>Сложность:</i></b> O(n²) в худшем и среднем случае.  <br>
<b><i>Плюсы:</i></b> проста в реализации.  <br>
<b><i>Минусы:</i></b> крайне медленная на больших массивах.  <br>
<b><i>Когда использовать:</i></b> для маленьких массивов или обучения.<br></p>
          <h3>Сортировка Выборкой (Selection Sort)</h3>
<p><b><i>Как работает:</i></b> находим минимальный элемент в неотсортированной части и ставим его в начало. Повторяем для оставшейся части.<br>
<b><i>Сложность:</i></b>  O(n²). <br>
<b><i>Плюсы:</i></b> мало обменов (n–1), проста. <br>
<b><i>Минусы:</i></b> медленная на больших данных. <br>
<b><i>Когда использовать:</i></b> если важна минимизация обменов.<br></p>
          <h3>Сортировка Вставками (Insertion Sort)</h3>
<p><b><i>Как работает:</i></b> берём элемент и вставляем его на правильное место в уже отсортированной части массива.  <br>
<b><i>Сложность:</i></b> O(n²) в худшем случае, O(n) в лучшем (если массив почти отсортирован).  <br>
<b><i>Плюсы:</i></b> эффективна на маленьких/почти отсортированных массивах; устойчива. <br>
<b><i>Минусы:</i></b>  медленно на больших случайных данных. <br>
<b><i>Когда использовать:</i></b>маленькие массивы или инкрементальная сортировка. <br></p>
          <h3>Сортировка Слиянием (Merge Sort)</h3>
<p><b><i>Как работает:</i></b> делим массив пополам, рекурсивно сортируем каждую половину, затем сливаем их в один отсортированный массив.  <br>
<b><i>Сложность:</i></b>O(n log n) всегда.   <br>
<b><i>Плюсы:</i></b> гарантированная производительность, устойчива, хорошо работает на больших данных. <br>
<b><i>Минусы:</i></b>  требует O(n) дополнительной памяти. <br>
<b><i>Когда использовать:</i></b>когда нужна стабильная O(n log n), даже для больших массивов. <br></p>
          <h2>2. Поиск</h2>
<p><b><i>Поиск</i></b> — нахождение элемента в структуре данных по заданному ключу.</p>
          <h3>Линейный поиск (Linear Search)</h3>
<p><b><i>Как работает:</i></b>  последовательно проверяем каждый элемент массива до нахождения нужного или конца массива. <br>
<b><i>Сложность:</i></b>  O(n).<br>
<b><i>Плюсы:</i></b> работает на любых массивах (отсортированных и нет), прост в реализации. <br>
<b><i>Минусы:</i></b>  медленный на больших массивах.<br>
<b><i>Когда использовать:</i></b>небольшие массивы или несортированные данные.</p>
          <h3>Бинарный поиск (Binary Search)</h3>
<p><b><i>Как работает:</i></b>  <br>
&emsp;1. Берём средний элемент отсортированного массива; <br>
&emsp;2. Если он равен искомому — нашли; <br>
&emsp;3. Если искомый меньше — ищем в левой половине, иначе — в правой; <br>
&emsp;4. Повторяем, пока элемент не найден или диапазон пуст. <br>
<b><i>Сложность:</i></b> O(log n).<br>
<b><i>Плюсы:</i></b> очень быстрый на больших отсортированных массивах. <br>
<b><i>Минусы:</i></b> требует отсортированных данных. <br>
<b><i>Когда использовать:</i></b> большие отсортированные массивы, частые поиски. <br>
</p>
        </section>
<br>
<br>
        
      </article>
    </div>
</div>
</body>
</html>